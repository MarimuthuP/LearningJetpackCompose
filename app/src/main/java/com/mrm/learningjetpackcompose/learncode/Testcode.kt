package com.mrm.learningjetpackcompose

import java.time.LocalDate
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.*


private var number: Int? = null

private var i = 0

fun main(args: Array<String>) {
    /*checkPalinPrimeNumbers()
    checkReverseNumber()
    checkRemainder()*/

    //checkArmstrongNumber()
    //checkArmstrongNumberBetweenTwoNumbers()
    //findTotalUnclosedBrackets()
    //printNumbers()

    //region Finding output from this snippet
    /*findOutputFromThisPart1()
    findOutputFromThisPart2()*/
    //endregion
    /*var numbers = listOf(1, 2, 3, 4)
    numbers + 5
    print(numbers)*/
    //checkScopeFunctions()

    checkNullSafeOperator()

    checkDataClasses()
    checkDataClassFromBioF()
    checkDataClassFromBioF1()

    checkResult() //Have you ever seen returning two values from a function?
    //region biofourmis exercise
    /*bioFourmisInterviewQuestions()
    val someClass = SomeClass()
    println("SomeClass initialised")
    someClass.accessObject()
    someClass.accessObject()*/
    //endregion
}

//Have you ever seen returning two values from a function?
data class Result(val result: Int, val status: String)

fun checkReturnValues(): Result{
    return Result(1,"success")
}

fun checkResult(){
    val (result, status) = checkReturnValues()
    println("Result - $result")
    println("status - $status")
}

fun checkDataClassFromBioF1() {
    println("**************** checkDataClassFromBioF1 *****************")
    val aVar by lazy {
        println("I am computing this value")
        "Hello"
    }
    println(aVar)
    println(aVar)
}

fun checkDataClassFromBioF() {
    println("**************** checkDataClassFromBioF *****************")
    var ab = Ab(10, "test")
    var (x,y) = ab
    x=15
    println(ab.a)
    println(y) //10, test
}

data class Ab(var a: Int, var b: String)

data class Character(val name: String, val age: Int)

fun checkDataClasses() {
    val mickeyMouse  = Character("Mickey Mouse", 82)
    val mickeyMouseToday = mickeyMouse.copy(age = 83)

    // destructuring declarations
    val (name, age) = mickeyMouseToday
    println("$name, $age years of age")

    mickeyMouseToday.component1() // => name
    mickeyMouseToday.component2() // => age
}

fun checkNullSafeOperator() {
    var a: String = "abc"
    //a = null  //compile time error

    val b: String? = null
    val value = b?.length
    //val result = b!!.length//returns null
    println("checkNullSafeOperator - $value")

    val nullableList: List<Int?> = listOf(1, 2, null, 4)
    val intList: List<Int> = nullableList.filterNotNull()
    println(intList)

    val date = "2022-07-20 05:17:11.000"
    val formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS")
    val dateTime = LocalDateTime.parse(date, formatter)
    val formatter2 = DateTimeFormatter.ofPattern("dd-MM-yyyy")
    val result = dateTime.format(formatter2)
    println("RESULT DATE - $result")
}

fun bioFourmisInterviewQuestions() {
    var a = 5
    a.let {
        println(it)
        a = 7
        println(it)
    }
}

class SomeClass {
    private val heavyObject: HeavyClass by lazy {
        println("Heavy object initialized")
        HeavyClass()
    }

    fun accessObject() {
        println(heavyObject)
    }
}

class HeavyClass {

}

fun checkScopeFunctions() {
    /*if(number!=null){
        val result = number!! + 100
    }*/

    val res = number?.let {
        val numb2 = it + 100
        numb2
    } ?: 0

    println("Number -> $res")

    println("square - ${getSquare()}")
}

fun getSquare() = (i * i).also { i = 80 }


private fun printNumbers() {
    toPrintAllNumbers()
    toPrintNumbersButExcludeOneAtFirst()
    toPrintNumbersButExceptOneNumber()
    toPrintNumbersInReverse()
    toRemoveVowelsFromGivenString("Vaazhga valamudan!")
    runningSumOf1DArray()


}


/**
 * used to Returns a list containing successive accumulation values generated by applying operation
 * from left to right to each element and current accumulator value that starts with the first
 * element of this array.
 */
fun runningSumOf1DArray() { //LeetCode problem this one is.
    val array = intArrayOf(1, 2, 3, 4)
    println("")
    print("runningSumOf1DArray - ")
    print(array.runningReduce { sum, element -> sum + element }.toIntArray())
}

fun toRemoveVowelsFromGivenString(name: String) {
    println("")
    print("toRemoveVowelsFromGivenString - ")
    val vowels = setOf('a', 'e', 'i', 'o', 'u')
    //print(name.filter { it !in vowels })
    print(name.filterNot { it in vowels })
}

fun toPrintNumbersInReverse() {
    val array = intArrayOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
    println("")
    print("toPrintNumbersInReverse - ")
    for (index in array.size - 1 downTo 1 step 3) {
        print(array[index])
    }
}

fun toPrintNumbersButExceptOneNumber() {
    val array = intArrayOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
    println("")
    print("toPrintNumbersButExceptOneNumber - ")
    for (index in array.indices - 5) {
        print(array[index])
    }
}

fun toPrintNumbersButExcludeOneAtFirst() {
    val array = intArrayOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
    println("")
    print("toPrintNumbersButExcludeOneAtFirst - ")
    for (index in 1 until array.size) {
        print(array[index])
    }
}

fun toPrintAllNumbers() {
    val array = intArrayOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
    println("")
    print("toPrintAllNumbers - ")
    for (index in array) {
        print(array[index])
    }
}

private fun findTotalUnclosedBrackets() {
    val inputString = "()))(("
    val inputSize = inputString.length
    var isOpened = 0
    var isClosed = 0
    var isItCorrect = 0

    var inputChars = inputString.toCharArray()
    for (i in 0 until inputSize) {

        if (inputChars[i] == ')' || inputChars[i] == ']' || inputChars[i] == '}') {
            break
        }

        if (inputChars[i] == '(') {
            isOpened++
            isItCorrect++
            continue
        }
        if (inputChars[i] == ')') {
            isClosed++
            isItCorrect--
            continue
        }
    }

    println("Total opened: $isOpened and closed: $isClosed")
    if (isOpened == isClosed && isItCorrect == 0) {
        println("Yes perfect string")
    } else {
        println("Not a perfect string")
    }
}

fun checkArmstrongNumber() {
    println("Enter the number to find Armstrong number")
    val input = readLine()!!.toInt()
    var remainder = 0
    var result = 0

    var originalNumber: Int = input

    while (originalNumber != 0) {
        remainder = originalNumber % 10
        //result += (remainder * remainder * remainder) Instead of this we can use as below
        result += Math.pow(remainder.toDouble(), 3.0).toInt()
        originalNumber /= 10
    }

    if (result == input)
        println("$input is an armstrong number")
    else
        println("$input is not an armstrong number")
}

fun checkArmstrongNumberBetweenTwoNumbers() {
    val totalInput = readLine()!!.toInt()
    for (i in 1..totalInput) {
        val limit = readLine()!!.split(' ')
        val startNumber = limit[0].toInt()
        val endNumber = limit[1].toInt()
        val totalArmstrongNumber = findTotalArmstrong(startNumber, endNumber)
        println("Total Armstrong no: $totalArmstrongNumber")
    }
}

fun findTotalArmstrong(startNumber: Int, endNumber: Int): Any {
    var start = startNumber
    var end = endNumber
    var count = 0

    for (number in start..end) {
        var digits = 0
        var origNumber = number
        var remainder = 0
        var result = 0

        while (origNumber != 0) {
            origNumber /= 10
            digits++
        }

        origNumber = number

        if (digits >= 2) {
            while (origNumber != 0) {
                remainder = origNumber % 10
                result += Math.pow(remainder.toDouble(), digits.toDouble()).toInt()
                origNumber /= 10
            }

            if (result == number) {
                count++
                println("----> $number")
            }
        }
    }
    return count
}

private fun findOutputFromThisPart2() {
    val c = mutableListOf("a", "b")
    val d: List<*> = c as List<*>
    print("d = $d")
    c.removeAt(0)
    print("d = $d")
}

private fun findOutputFromThisPart1() {
    val a = listOf(1, 2, 3).fold(0) { one, two -> one + two }
    println("VALUEEEE -> $a")
    val num: Int = 8
    println(num)
}

private fun checkPalinPrimeNumbers() {
    println("Enter the number limit: ")
    val input = readLine()!!.toInt()
    println("Enter the number and tap space and enter another number: ")
    for (i in 1..input) {
        val limit = readLine()!!.split(' ')
        val l = limit[0].toInt()
        val r = limit[1].toInt()
        val out_: Int = palPrime(l, r)
        println(out_)
    }
}

/**
 * This method is used to find the Prime Palindrome numbers
 */
fun palPrime(L: Int, R: Int): Int {
    var fromNum = L
    var toNum = R
    var palPrimeCount = 0
    while (fromNum <= toNum) {
        if (checkPrimeNumber(fromNum)) {
            if (checkPalinNumber(fromNum)) {
                println("yes PalinPrime ----->: $fromNum")
                palPrimeCount++
            }
        }
        fromNum++
    }
    return palPrimeCount
}

/**
 * This method is used to find whether the given number is prime or not.
 */
fun checkPrimeNumber(number: Int): Boolean {
    var flag = true
    for (i in 2..(number / 2)) {
        if (number % 2 == 0) {
            flag = false
            break
        }
    }
    return flag
}

/**
 * This method is used to find whether the given number is meet the palindrome format.
 */
fun checkPalinNumber(num: Int): Boolean {
    var input = num
    var origNum = num
    var remainder = 0
    var reverseNum = 0

    while (input != 0) {
        remainder = input % 10
        reverseNum = reverseNum * 10 + remainder
        input /= 10
    }
    return (origNum == reverseNum)
}

/**
 * This method is used to find the quotient and remainder based on given inputs.
 */
fun checkRemainder() {
    println("Enter the dividend and divisor: ")
    val dividend = readLine()!!.toInt()
    val divisor = readLine()!!.toInt()

    val quotient = dividend / divisor
    val remainder = dividend % divisor

    println("Quotient = $quotient")
    println("Remainder = $remainder")
}

/**
 * This method is used to reverse the number.
 */
fun checkReverseNumber() {
    println("Enter the number to find Reverse number")
    val input = readLine()!!.toInt()

    var number = input
    var remainder: Int
    var reverseNum = 0

    while (number != 0) {
        remainder = number % 10
        reverseNum = reverseNum * 10 + remainder
        number /= 10
    }
    println("Reverse no: $reverseNum")
}
